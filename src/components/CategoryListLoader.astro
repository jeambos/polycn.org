---
// src/components/CategoryListLoader.astro
import fs from 'node:fs';
import path from 'node:path';
import { getLibraryItems } from '../utils/dataLoader';
import DirectoryListing from './DirectoryListing.jsx';

const { subdir } = Astro.props; 

// 获取扁平化后的数据
const rawItems = await getLibraryItems(subdir);
const bookNameCache = new Map();

/**
 * 读取书籍显示名称
 */
const getBookDisplayName = (folderKey) => {
  if (!folderKey) return '';
  if (bookNameCache.has(folderKey)) return bookNameCache.get(folderKey);

  let displayName = folderKey;
  
  try {
    const metaPath = path.join(process.cwd(), 'src/content/docs', subdir, folderKey, '_meta.json');
    if (fs.existsSync(metaPath)) {
      const metaContent = fs.readFileSync(metaPath, 'utf-8');
      const metaJson = JSON.parse(metaContent);
      if (metaJson.name) {
        displayName = metaJson.name;
      }
    }
  } catch (e) {
    // 忽略读取错误
  }

  bookNameCache.set(folderKey, displayName);
  return displayName;
};

const processedItems = rawItems.map((item) => {
  // ✅ 修复 1：不再读取 item.data，直接读取扁平属性
  let safeTime = 0;
  // item.date 在类型定义里是 true | Date，我们只处理 Date 或字符串情况
  const rawDate = item.date; 
  
  if (rawDate && rawDate !== true) {
    const d = rawDate instanceof Date ? rawDate : new Date(rawDate);
    if (!isNaN(d.getTime())) safeTime = d.getTime();
  }

  // ✅ 修复 2：不再使用 item.slug，改用 item.id
  // 在 getLibraryItems 返回的对象中，id 通常就是 slug 或文件路径
  const slug = item.id;

  // 尝试提取 folderKey (书名)
  let currentFolderKey = item.folderKey;
  
  // 如果没有 folderKey，尝试从 id/slug 中解析
  // 假设结构: library/books/ethical-slut/chapter-1
  if (!currentFolderKey && slug) {
     const parts = slug.split('/');
     // parts[0]=library, parts[1]=books, parts[2]=folderKey
     if (parts.length >= 3) currentFolderKey = parts[2];
  }

  const displayName = getBookDisplayName(currentFolderKey);

  // ✅ 修复 3：链接生成
  // 如果 item.link 存在则使用，否则使用 /id 作为回退
  const finalLink = item.link || `/${slug}`;

  return {
    id: item.id,
    title: item.title, // ✅ 直接读取 title，而不是 item.data.title
    link: finalLink,
    folderKey: currentFolderKey,
    bookDisplayName: displayName || currentFolderKey,
    timestamp: safeTime,
    dateObj: safeTime ? new Date(safeTime) : null,
  };
});

// 排序：按时间倒序
const sortedItems = processedItems.sort((a, b) => b.timestamp - a.timestamp);
---

<DirectoryListing client:load items={sortedItems} />